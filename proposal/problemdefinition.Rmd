## The Problem
To adopt the latest advances in data manipulation is central for keeping R an attrictive choice of language within the field of data science.
For anyone in the R cummunity where CPU-time and/or in-memory size is a bottleneck, using newly available [polars](pola.rs) with optional out-of-memory execution can be a huge gain. Bindings for the core implementation of polars, called rust-polars, are available for python called py-polars. I, Soren Welling, have been studying polars source code and writing the r-polars bindings full time since March 2022. So far about 350 methods including close to all of the 'lazy' polars expression syntax has been translated. Any known difficult integration e.g. calling R functions from polars threads has been solved. However r-polars is missing more regular method translations to become feature complete, especially for the 'eager' syntax. Personally it would strain my economy to sponsor another needed half year on the project, which is why I humbly apply here for 

## Current alternatives
Already, r-arrow exists, which is likewise based on the Apache Arrow memory format.
The packages r-polars and r-arrow can co-exist well as they have near zero-copy conversion and the same underlying types, making it easy to e.g. borrow a data conector from the other package. Polars currently have a stronger emphasis for multi-threaded computation + query optimization, making it the current 'king of the hill' in a wide set of benchmarks. Rspark and sparklyr likewise provide similar functionality as polars. However, as r-polars is completely self-contained as an R package with no dependencies, there is no need for third-party installations nor cluster configuration. This makes r-polars a simple choice to start early development on a single desktop, with the option to later deploy the same code in cloud 'as is' on e.g. a 64 core instance with no cluster-communication overhead.
